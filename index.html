<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosquito Interactive Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        #videoElement {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 150px;
            border: 2px solid #fff;
            border-radius: 8px;
            display: none;
            z-index: 1000;
        }

        #debugInfo {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-family: monospace;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 2000;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            z-index: 2001;
            display: none;
        }

        #startButton:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <video id="videoElement" autoplay playsinline></video>
        <div id="debugInfo"></div>
        <div id="loadingScreen">
            <div class="spinner"></div>
            <div>Loading resources...</div>
        </div>
        <button id="startButton">Click to Start</button>
    </div>

    <!-- MediaPipe Hands library -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // Game configuration
        const CONFIG = {
            backgroundWidth: 2880,
            backgroundHeight: 2048,
            insecticideWidth: 297,
            insecticideHeight: 477,
            insecticideRotation: 21.01,
            mosquitoCount: 5,
            mosquitoSize: 2.5,
            mosquitoSpeed: 2,
            clapDistance: 150,  // Clap detection distance
            clapKillRadius: 150,  // Clap kill radius
            swatterGrabDistance: 300,  // Swatter grab distance
            zapKillRadius: 100,  // Electric swatter kill radius
            gameRestartDelay: 2000
        };

        // Game state
        const GAME_STATE = {
            LOADING: 'loading',
            BLACK_SCREEN: 'black_screen',
            BUZZING: 'buzzing',
            EYE_OPENING: 'eye_opening',
            PLAYING: 'playing',
            EYE_CLOSING: 'eye_closing',
            RESTARTING: 'restarting'
        };

        class MosquitoGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.videoElement = document.getElementById('videoElement');
                this.debugInfo = document.getElementById('debugInfo');
                this.loadingScreen = document.getElementById('loadingScreen');
                this.startButton = document.getElementById('startButton');

                this.state = GAME_STATE.LOADING;
                this.mosquitos = [];
                this.hands = [];
                this.previousHandPositions = [];
                this.backgroundImg = null;
                this.insecticideImg = null;
                this.insecticidePos = null;
                this.insecticideOriginalPos = null;
                this.isHoldingInsecticide = false;
                this.swatterHandPos = null;
                this.eyeOpenProgress = 0;
                this.audioContext = null;
                this.buzzingSource = null;
                this.buzzingGain = null;
                this.buzzingAudioBuffer = null;
                this.zapAudioBuffer = null;
                this.zapSource = null;

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.init();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            async init() {
                try {
                    // Load images
                    await this.loadImages();

                    // Setup audio
                    this.setupAudio();

                    // Setup hand tracking
                    await this.setupHandTracking();

                    // Calculate insecticide position
                    this.calculateInsecticidePosition();

                    // Show start button
                    this.loadingScreen.style.display = 'none';
                    this.startButton.style.display = 'block';

                    this.startButton.addEventListener('click', () => {
                        this.startButton.style.display = 'none';
                        this.startGame();
                    });

                } catch (error) {
                    console.error('Initialization error:', error);
                    this.loadingScreen.innerHTML = `<div style="color: red;">Loading failed: ${error.message}</div>`;
                }
            }

            async loadImages() {
                return new Promise((resolve, reject) => {
                    let loaded = 0;
                    const total = 2;

                    const checkComplete = () => {
                        loaded++;
                        if (loaded === total) resolve();
                    };

                    this.backgroundImg = new Image();
                    this.backgroundImg.onload = checkComplete;
                    this.backgroundImg.onerror = () => reject(new Error('Failed to load Background.png'));
                    this.backgroundImg.src = 'Background.png';

                    this.insecticideImg = new Image();
                    this.insecticideImg.onload = checkComplete;
                    this.insecticideImg.onerror = () => reject(new Error('Failed to load electronic mosquito swatter.png'));
                    this.insecticideImg.src = 'electronic mosquito swatter.png';
                });
            }

            async setupAudio() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Load buzzing sound from audio file
                try {
                    // Add cache-busting parameter to force reload
                    const response = await fetch('580629__vilatzara__mosquito1.wav?v=' + Date.now());
                    const arrayBuffer = await response.arrayBuffer();
                    this.buzzingAudioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    console.log('Mosquito audio loaded successfully:', this.buzzingAudioBuffer.duration, 'seconds');
                } catch (error) {
                    console.error('Failed to load mosquito audio file:', error);
                    this.buzzingAudioBuffer = null;
                }

                // Load electric zap sound
                try {
                    const response = await fetch('399549__soundslikewillem__electric-mosquito-killer-bat.wav?v=' + Date.now());
                    const arrayBuffer = await response.arrayBuffer();
                    this.zapAudioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    console.log('Zap audio loaded successfully:', this.zapAudioBuffer.duration, 'seconds');
                } catch (error) {
                    console.error('Failed to load zap audio file:', error);
                    this.zapAudioBuffer = null;
                }
            }

            // Play buzzing sound with varying volume (near/far effect)
            playBuzzingSound() {
                if (!this.audioContext) return;

                // Stop existing sound if any
                this.stopBuzzingSound();

                if (this.buzzingAudioBuffer) {
                    // Use loaded audio file
                    this.buzzingSource = this.audioContext.createBufferSource();
                    this.buzzingGain = this.audioContext.createGain();

                    this.buzzingSource.buffer = this.buzzingAudioBuffer;
                    this.buzzingSource.loop = true;

                    // Start with medium volume
                    this.buzzingGain.gain.setValueAtTime(0.3, this.audioContext.currentTime);

                    this.buzzingSource.connect(this.buzzingGain);
                    this.buzzingGain.connect(this.audioContext.destination);

                    this.buzzingSource.start();

                    // Add volume variation for near/far effect
                    this.buzzVolumeVariation();
                } else {
                    // Fallback to synthesized sound
                    this.buzzingSource = this.audioContext.createOscillator();
                    this.buzzingGain = this.audioContext.createGain();

                    this.buzzingSource.type = 'sawtooth';
                    this.buzzingSource.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    this.buzzingGain.gain.setValueAtTime(0.1, this.audioContext.currentTime);

                    this.buzzingSource.connect(this.buzzingGain);
                    this.buzzingGain.connect(this.audioContext.destination);

                    this.buzzingSource.start();
                    this.buzzVolumeVariation();
                }
            }

            // Add volume variation for realistic near/far effect
            buzzVolumeVariation() {
                if (!this.buzzingGain) return;

                const currentTime = this.audioContext.currentTime;
                const duration = 1.5 + Math.random() * 2; // Change every 1.5-3.5 seconds

                // Random volume between 0.05 (far) and 0.6 (near)
                const targetVolume = 0.05 + Math.random() * 0.55;
                this.buzzingGain.gain.linearRampToValueAtTime(targetVolume, currentTime + duration);

                // Continue variation
                this.buzzVolumeTimeout = setTimeout(() => this.buzzVolumeVariation(), duration * 1000);
            }

            stopBuzzingSound() {
                if (this.buzzingSource) {
                    try {
                        if (this.buzzingGain) {
                            this.buzzingGain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.1);
                        }
                        this.buzzingSource.stop(this.audioContext.currentTime + 0.2);
                    } catch (e) {
                        // Source already stopped
                    }
                    this.buzzingSource = null;
                    this.buzzingGain = null;
                }

                // Clear volume variation timeout
                if (this.buzzVolumeTimeout) {
                    clearTimeout(this.buzzVolumeTimeout);
                    this.buzzVolumeTimeout = null;
                }
            }

            // Play electric zap sound (6x volume)
            playZapSound() {
                if (!this.audioContext || !this.zapAudioBuffer) return;

                // Stop previous sound to avoid overlapping
                if (this.zapSource) {
                    try {
                        this.zapSource.stop();
                    } catch (e) {
                        // Source already stopped
                    }
                    this.zapSource = null;
                }

                const source = this.audioContext.createBufferSource();
                const gainNode = this.audioContext.createGain();

                source.buffer = this.zapAudioBuffer;
                // 6x volume (louder)
                gainNode.gain.setValueAtTime(6.0, this.audioContext.currentTime);

                source.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                // Save source reference
                this.zapSource = source;

                // Clear reference when sound ends
                source.onended = () => {
                    this.zapSource = null;
                };

                source.start();
            }

            async setupHandTracking() {
                const hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });

                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults((results) => this.onHandResults(results));

                const camera = new Camera(this.videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: this.videoElement });
                    },
                    width: 640,
                    height: 480
                });

                await camera.start();
            }

            onHandResults(results) {
                this.hands = results.multiHandedness && results.multiHandLandmarks
                    ? results.multiHandLandmarks.map((landmarks, idx) => ({
                        landmarks: landmarks,
                        handedness: results.multiHandedness[idx].label
                    }))
                    : [];
            }

            calculateInsecticidePosition() {
                const scaleX = this.canvas.width / CONFIG.backgroundWidth;
                const scaleY = this.canvas.height / CONFIG.backgroundHeight;
                const scale = Math.min(scaleX, scaleY);

                const bgWidth = CONFIG.backgroundWidth * scale;
                const bgHeight = CONFIG.backgroundHeight * scale;
                const offsetX = (this.canvas.width - bgWidth) / 2;
                const offsetY = (this.canvas.height - bgHeight) / 2;

                // Store background bounds for mosquito movement
                this.backgroundBounds = {
                    left: offsetX,
                    right: offsetX + bgWidth,
                    top: offsetY,
                    bottom: offsetY + bgHeight,
                    width: bgWidth,
                    height: bgHeight
                };

                // Position insecticide at a visible location (right side)
                this.insecticideOriginalPos = {
                    x: offsetX + bgWidth * 0.8,
                    y: offsetY + bgHeight * 0.6,
                    width: CONFIG.insecticideWidth * scale,
                    height: CONFIG.insecticideHeight * scale,
                    rotation: CONFIG.insecticideRotation * Math.PI / 180,
                    scale: scale
                };
                this.insecticidePos = {...this.insecticideOriginalPos}; // 初始位置
            }

            createMosquitos() {
                this.mosquitos = [];

                // Make sure background bounds are calculated
                if (!this.backgroundBounds) {
                    this.calculateInsecticidePosition();
                }

                const bounds = this.backgroundBounds;
                const margin = 50; // Keep mosquito away from edges

                for (let i = 0; i < CONFIG.mosquitoCount; i++) {
                    this.mosquitos.push({
                        x: bounds.left + margin + Math.random() * (bounds.width - margin * 2),
                        y: bounds.top + margin + Math.random() * (bounds.height - margin * 2),
                        vx: (Math.random() - 0.5) * CONFIG.mosquitoSpeed,
                        vy: (Math.random() - 0.5) * CONFIG.mosquitoSpeed,
                        size: CONFIG.mosquitoSize,
                        angle: Math.random() * Math.PI * 2,
                        alive: true
                    });
                }
            }

            startGame() {
                this.state = GAME_STATE.BLACK_SCREEN;
                this.eyeOpenProgress = 0;
                this.createMosquitos();

                // Black screen for 2 seconds
                setTimeout(() => {
                    // Buzzing sound starts (lasts 2 seconds)
                    this.state = GAME_STATE.BUZZING;
                    this.playBuzzingSound();

                    // Eye opening after 2 seconds
                    setTimeout(() => {
                        this.state = GAME_STATE.EYE_OPENING;
                        this.animateEyeOpening();
                    }, 2000);
                }, 2000);

                this.gameLoop();
            }

            animateEyeOpening() {
                const duration = 1500; // 1.5 seconds
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    this.eyeOpenProgress = Math.min(elapsed / duration, 1);

                    if (this.eyeOpenProgress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.state = GAME_STATE.PLAYING;
                    }
                };

                animate();
            }

            animateEyeClosing() {
                const duration = 1000; // 1 second
                const startTime = Date.now();
                const startProgress = this.eyeOpenProgress;

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    this.eyeOpenProgress = startProgress * (1 - progress);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.state = GAME_STATE.RESTARTING;
                        setTimeout(() => this.startGame(), CONFIG.gameRestartDelay);
                    }
                };

                animate();
            }

            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                if (this.state !== GAME_STATE.PLAYING) return;

                // Update mosquito positions
                const bounds = this.backgroundBounds;
                this.mosquitos.forEach(mosquito => {
                    if (!mosquito.alive) return;

                    mosquito.x += mosquito.vx;
                    mosquito.y += mosquito.vy;
                    mosquito.angle += 0.05;

                    // Bounce off background boundaries
                    if (mosquito.x < bounds.left || mosquito.x > bounds.right) mosquito.vx *= -1;
                    if (mosquito.y < bounds.top || mosquito.y > bounds.bottom) mosquito.vy *= -1;

                    // Keep within background bounds
                    mosquito.x = Math.max(bounds.left, Math.min(bounds.right, mosquito.x));
                    mosquito.y = Math.max(bounds.top, Math.min(bounds.bottom, mosquito.y));
                });

                // Check for hand interactions
                this.checkHandInteractions();

                // Check if all mosquitos are dead
                const allDead = this.mosquitos.every(m => !m.alive);
                if (allDead && this.state === GAME_STATE.PLAYING) {
                    // All mosquitos are dead, stop buzzing sound
                    this.stopBuzzingSound();
                    this.state = GAME_STATE.EYE_CLOSING;
                    this.animateEyeClosing();
                }
            }

            checkHandInteractions() {
                if (this.hands.length === 0) {
                    this.previousHandPositions = [];
                    // Reset swatter if no hands detected
                    this.isHoldingInsecticide = false;
                    this.swatterHandPos = null;
                    if (this.insecticideOriginalPos) {
                        this.insecticidePos = {...this.insecticideOriginalPos};
                    }
                    return;
                }

                // Get hand positions in canvas coordinates (with mirror flip)
                const handPositions = this.hands.map(hand => {
                    // Calculate palm center using multiple keypoints
                    const wrist = hand.landmarks[0];
                    const indexMcp = hand.landmarks[5];
                    const middleMcp = hand.landmarks[9];
                    const ringMcp = hand.landmarks[13];
                    const pinkyMcp = hand.landmarks[17];
                    const indexTip = hand.landmarks[8];

                    const palmCenter = {
                        x: (1 - ((wrist.x + indexMcp.x + middleMcp.x + ringMcp.x + pinkyMcp.x) / 5)) * this.canvas.width,
                        y: ((wrist.y + indexMcp.y + middleMcp.y + ringMcp.y + pinkyMcp.y) / 5) * this.canvas.height
                    };

                    return {
                        palmCenter: palmCenter,
                        indexTip: {
                            x: (1 - indexTip.x) * this.canvas.width,
                            y: indexTip.y * this.canvas.height
                        },
                        handedness: hand.handedness
                    };
                });

                // Check for clapping
                if (handPositions.length === 2) {
                    const currentDist = this.distance(
                        handPositions[0].palmCenter,
                        handPositions[1].palmCenter
                    );

                    if (currentDist < CONFIG.clapDistance) {
                        const centerX = (handPositions[0].palmCenter.x + handPositions[1].palmCenter.x) / 2;
                        const centerY = (handPositions[0].palmCenter.y + handPositions[1].palmCenter.y) / 2;

                        this.mosquitos.forEach(mosquito => {
                            if (!mosquito.alive) return;
                            const distToCenter = Math.sqrt(
                                Math.pow(mosquito.x - centerX, 2) +
                                Math.pow(mosquito.y - centerY, 2)
                            );
                            if (distToCenter < CONFIG.clapKillRadius) {
                                mosquito.alive = false;
                            }
                        });
                    }
                }

                // Check for grabbing and using electric mosquito swatter
                let stillHolding = false;
                let mosquitoKilledByZap = false;

                handPositions.forEach((handPos, idx) => {
                    const originalHand = this.hands[idx];
                    const isFistNow = this.isFist(originalHand);

                    // If already holding swatter
                    if (this.isHoldingInsecticide) {
                        // Keep holding as long as fist is closed
                        if (isFistNow) {
                            stillHolding = true;
                            this.swatterHandPos = handPos.indexTip;

                            // Update swatter position
                            this.insecticidePos.x = handPos.indexTip.x;
                            this.insecticidePos.y = handPos.indexTip.y;

                            // Check if mosquito is hit by swatter
                            this.mosquitos.forEach(mosquito => {
                                if (!mosquito.alive) return;
                                const distToMosquito = this.distance(handPos.indexTip, mosquito);
                                if (distToMosquito < CONFIG.zapKillRadius) {
                                    mosquito.alive = false;
                                    mosquitoKilledByZap = true;
                                }
                            });
                        }
                    } else {
                        // If not holding yet, check if near swatter
                        const distToSwatter = this.distance(handPos.indexTip, this.insecticideOriginalPos);

                        if (distToSwatter < CONFIG.swatterGrabDistance && isFistNow) {
                            this.isHoldingInsecticide = true;
                            stillHolding = true;
                            this.swatterHandPos = handPos.indexTip;
                            this.insecticidePos.x = handPos.indexTip.x;
                            this.insecticidePos.y = handPos.indexTip.y;
                        }
                    }
                });

                // Play zap sound if mosquito was killed
                if (mosquitoKilledByZap) {
                    this.playZapSound();
                }

                // Reset swatter position if not holding
                if (!stillHolding) {
                    this.isHoldingInsecticide = false;
                    this.swatterHandPos = null;
                    if (this.insecticideOriginalPos) {
                        this.insecticidePos.x = this.insecticideOriginalPos.x;
                        this.insecticidePos.y = this.insecticideOriginalPos.y;
                    }
                }

                // Save current positions for next frame
                this.previousHandPositions = handPositions;
            }

            checkMosquitoKill(position, radius) {
                this.mosquitos.forEach(mosquito => {
                    if (!mosquito.alive) return;
                    const dist = this.distance(position, mosquito);
                    if (dist < radius) {
                        mosquito.alive = false;
                        // Don't stop buzzing here, only when all mosquitos are dead
                    }
                });
            }

            distance(p1, p2) {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // Detect if hand is making a fist
            isFist(hand) {
                // Check if all fingertips are close to wrist
                const wrist = hand.landmarks[0];
                const fingerTips = [
                    hand.landmarks[4],  // Thumb tip
                    hand.landmarks[8],  // Index tip
                    hand.landmarks[12], // Middle tip
                    hand.landmarks[16], // Ring tip
                    hand.landmarks[20]  // Pinky tip
                ];

                // Calculate average distance from fingertips to wrist
                let totalDistance = 0;
                fingerTips.forEach(tip => {
                    const dx = tip.x - wrist.x;
                    const dy = tip.y - wrist.y;
                    const dz = tip.z - wrist.z;
                    totalDistance += Math.sqrt(dx * dx + dy * dy + dz * dz);
                });
                const avgDistance = totalDistance / fingerTips.length;

                // Threshold: fist ~0.08-0.15, open hand ~0.18-0.3
                // Using 0.20 for easier fist detection
                this.lastFistDistance = avgDistance;
                return avgDistance < 0.20;
            }

            render() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Only show black screen during LOADING, BLACK_SCREEN, BUZZING states
                if (this.state === GAME_STATE.LOADING ||
                    this.state === GAME_STATE.BLACK_SCREEN ||
                    this.state === GAME_STATE.BUZZING) {
                    return;
                }

                // Calculate eye opening effect
                let visibleHeight = this.canvas.height;
                if (this.state === GAME_STATE.EYE_OPENING || this.state === GAME_STATE.EYE_CLOSING) {
                    visibleHeight = this.canvas.height * this.eyeOpenProgress;
                }

                this.ctx.save();
                this.ctx.beginPath();
                const yOffset = (this.canvas.height - visibleHeight) / 2;
                this.ctx.rect(0, yOffset, this.canvas.width, visibleHeight);
                this.ctx.clip();

                // Draw background
                if (this.backgroundImg) {
                    const scaleX = this.canvas.width / CONFIG.backgroundWidth;
                    const scaleY = this.canvas.height / CONFIG.backgroundHeight;
                    const scale = Math.min(scaleX, scaleY);

                    const bgWidth = CONFIG.backgroundWidth * scale;
                    const bgHeight = CONFIG.backgroundHeight * scale;
                    const offsetX = (this.canvas.width - bgWidth) / 2;
                    const offsetY = (this.canvas.height - bgHeight) / 2;

                    this.ctx.drawImage(this.backgroundImg, offsetX, offsetY, bgWidth, bgHeight);
                }

                // Draw insecticide
                if (this.insecticideImg && this.insecticidePos) {
                    this.ctx.save();
                    this.ctx.translate(this.insecticidePos.x, this.insecticidePos.y);
                    this.ctx.rotate(this.insecticidePos.rotation);
                    this.ctx.drawImage(
                        this.insecticideImg,
                        -this.insecticidePos.width / 2,
                        -this.insecticidePos.height / 2,
                        this.insecticidePos.width,
                        this.insecticidePos.height
                    );
                    this.ctx.restore();
                }

                // Draw mosquitos as small black dots (no border)
                this.mosquitos.forEach(mosquito => {
                    if (!mosquito.alive) return;

                    this.ctx.save();
                    this.ctx.fillStyle = '#000';
                    this.ctx.beginPath();
                    this.ctx.arc(mosquito.x, mosquito.y, mosquito.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });

                // Draw hands (with mirror flip)
                this.hands.forEach(hand => {
                    hand.landmarks.forEach((landmark, idx) => {
                        const x = (1 - landmark.x) * this.canvas.width;  // 镜像翻转
                        const y = landmark.y * this.canvas.height;

                        this.ctx.fillStyle = idx === 8 ? '#00FF00' : '#FF0000';
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 5, 0, Math.PI * 2);
                        this.ctx.fill();
                    });
                });

                this.ctx.restore();

                // Draw debug info
                this.updateDebugInfo();
            }

            updateDebugInfo() {
                const aliveMosquitos = this.mosquitos.filter(m => m.alive).length;
                let debugText = `
                    State: ${this.state}<br>
                    Mosquitos: ${aliveMosquitos}/${this.mosquitos.length}<br>
                    Hands detected: ${this.hands.length}<br>
                    Holding swatter: ${this.isHoldingInsecticide ? 'Yes' : 'No'}<br>
                `;

                // Show swatter position info
                if (this.insecticidePos && this.insecticideOriginalPos) {
                    const moved = Math.abs(this.insecticidePos.x - this.insecticideOriginalPos.x) > 1 ||
                                  Math.abs(this.insecticidePos.y - this.insecticideOriginalPos.y) > 1;
                    debugText += `Swatter moved: ${moved ? 'Yes' : 'No'} (${Math.round(this.insecticidePos.x)},${Math.round(this.insecticidePos.y)})<br>`;
                }

                // Show fist detection status
                if (this.hands.length > 0 && this.lastFistDistance !== undefined) {
                    const isFist = this.lastFistDistance < 0.20;
                    debugText += `Fist detection: ${isFist ? 'Fist' : 'Open'} (${this.lastFistDistance.toFixed(3)} < 0.20)<br>`;
                }

                // Show hand to swatter distance
                if (this.hands.length > 0 && this.insecticideOriginalPos) {
                    const handPos = this.hands[0].landmarks[8];
                    const handX = (1 - handPos.x) * this.canvas.width;
                    const handY = handPos.y * this.canvas.height;
                    const distToSwatter = Math.sqrt(
                        Math.pow(handX - this.insecticideOriginalPos.x, 2) +
                        Math.pow(handY - this.insecticideOriginalPos.y, 2)
                    );
                    debugText += `Hand to swatter: ${Math.round(distToSwatter)}px (< ${CONFIG.swatterGrabDistance})<br>`;
                }

                // Show hand distance for clap detection
                if (this.hands.length === 2 && this.previousHandPositions.length === 2) {
                    const handPositions = this.hands.map(hand => {
                        const wrist = hand.landmarks[0];
                        const indexMcp = hand.landmarks[5];
                        const middleMcp = hand.landmarks[9];
                        const ringMcp = hand.landmarks[13];
                        const pinkyMcp = hand.landmarks[17];

                        return {
                            x: (1 - ((wrist.x + indexMcp.x + middleMcp.x + ringMcp.x + pinkyMcp.x) / 5)) * this.canvas.width,
                            y: ((wrist.y + indexMcp.y + middleMcp.y + ringMcp.y + pinkyMcp.y) / 5) * this.canvas.height
                        };
                    });

                    const currentDist = this.distance(handPositions[0], handPositions[1]);
                    debugText += `Hands distance: ${Math.round(currentDist)}px`;
                }

                this.debugInfo.innerHTML = debugText;
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            new MosquitoGame();
        });
    </script>
</body>
</html>
